enum Something {
    Hello
}
model Post {
    fields {
        title Text
    }

    operations {
        get getPost(id)
    }

    functions {
        create createPost() with (title)
    }
}

api Web {
    @graphql

    models {
        Post
    }
}

====

export type Timestamp = string
import { QueryConstraints, ChainableQuery, Query } from '@teamkeel/sdk';
import { DatabasePool } from 'slonik';
import {
  FunctionError,
  FunctionCreateResponse,
  FunctionGetResponse,
  FunctionDeleteResponse,
  FunctionListResponse,
  FunctionUpdateResponse,
  FunctionAuthenticateResponse
} from '@teamkeel/sdk';

export interface Post {
  title: string
  id: string
  createdAt: Date
  updatedAt: Date
}

export interface Identity {
  email: string
  password: string
  id: string
  createdAt: Date
  updatedAt: Date
}
export declare enum Something {
  Hello = "Hello"
}export interface GetPostInput {
  id: string
}
export interface CreatePostInput {
  title: string
}
export interface AuthenticateInput {
  createIfNotExists?: boolean
  email: string
  password: string
}

declare type CreatePostReturnType = Promise<FunctionCreateResponse<Post>>

declare type CreatePostCallbackFunction = (inputs: CreatePostInput, api: API) => CreatePostReturnType

export declare const CreatePost : (callback: CreatePostCallbackFunction) => (inputs: CreatePostInput, api: API) => CreatePostReturnType

export declare type PostQuery = Partial<{
  title?: QueryConstraints.StringConstraint
  id?: QueryConstraints.StringConstraint
  createdAt?: QueryConstraints.DateConstraint
  updatedAt?: QueryConstraints.DateConstraint
}>

export declare type PostUniqueFields = Partial<{
  id?: QueryConstraints.StringConstraint
}>

export declare class PostApi {
  private readonly db;
  constructor();
  create: (inputs: Partial<Omit<Post, "id" | "createdAt" | "updatedAt">>) => Promise<FunctionCreateResponse<Post>>;
  where: (conditions: PostQuery) => ChainableQuery<Post>;
  delete: (id: string) => Promise<FunctionDeleteResponse<Post>>;
  findOne: (query: PostUniqueFields) => Promise<FunctionGetResponse<Post>>;
  update: (id: string, inputs: Partial<Omit<Post, "id" | "createdAt" | "updatedAt">>) => Promise<FunctionUpdateResponse<Post>>;
  findMany: (query: PostQuery) => Promise<FunctionListResponse<Post>>;
}

export declare type IdentityQuery = Partial<{
  email?: QueryConstraints.StringConstraint
  password?: QueryConstraints.StringConstraint
  id?: QueryConstraints.StringConstraint
  createdAt?: QueryConstraints.DateConstraint
  updatedAt?: QueryConstraints.DateConstraint
}>

export declare type IdentityUniqueFields = Partial<{
  email?: QueryConstraints.StringConstraint
id?: QueryConstraints.StringConstraint
}>

export declare class IdentityApi {
  private readonly db;
  constructor();
  create: (inputs: Partial<Omit<Identity, "id" | "createdAt" | "updatedAt">>) => Promise<FunctionCreateResponse<Identity>>;
  where: (conditions: IdentityQuery) => ChainableQuery<Identity>;
  delete: (id: string) => Promise<FunctionDeleteResponse<Identity>>;
  findOne: (query: IdentityUniqueFields) => Promise<FunctionGetResponse<Identity>>;
  update: (id: string, inputs: Partial<Omit<Identity, "id" | "createdAt" | "updatedAt">>) => Promise<FunctionUpdateResponse<Identity>>;
  findMany: (query: IdentityQuery) => Promise<FunctionListResponse<Identity>>;
}

import { Logger } from '@teamkeel/sdk'

export interface API {
  models: {
    post: PostApi
    identity: IdentityApi
  },
  logger: Logger
}
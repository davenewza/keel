import {
  Logger,
  queryResolverFromEnv,
} from '@teamkeel/functions-runtime';
import { ActionExecutor } from '@teamkeel/functions-testing';

const qr = queryResolverFromEnv(process.env);
const parentPort = parseInt(process.env.PARENT_PORT, 10);
const host = process.env.HOST || 'localhost';
const queryLogger = new Logger();
const actionExecutor = new ActionExecutor({ parentPort, host });

// Actions contains all of the Keel schema actions - both built-in actions
// defined in an *operations* block and custom operations defined in a *functions*
// block.
class ActionsWithIdentity {
  constructor(identity) {
    if (identity === undefined) {
      throw new Error('valid identity was not provided to withIdentity.');
    }
    this.identity = identity;
    {{- range .Actions }}
    this.{{ .NameLowerCamel }} = async (payload) => await actionExecutor.execute({
      actionName: "{{ .NameLowerCamel }}",
      payload,
      identity: this.identity,
    });
    {{- end }}
  }
}

export class Actions {
  constructor() {
    this.withIdentity = (identity) => {
      return new ActionsWithIdentity(identity);
    };
    {{- range .Actions }}
    this.{{ .NameLowerCamel }} = async (payload) => await actionExecutor.execute({
      actionName: "{{ .NameLowerCamel }}",
      payload,
    });
    {{- end }}
  }
}
export const actions = new Actions();

{{- range .Models }}
class {{ .ApiName }} {
  constructor() {
    this.create = async (inputs) => {
      const q = await this.query()
      return q.create(inputs);
    }

    this.where = (conditions) => {
      return new ChainableQuery({
        tableName: '{{ .TableName }}',
        queryResolver: qr,
        conditions: [conditions],
        logger: queryLogger,
      })
    }

    this.delete = async (id) => {
      const q = await this.query()
      return q.delete(id);
    }

    this.findOne = async (query) => {
      const q = await this.query()
      return q.findOne(query as any);
    }

    this.update = async (id, inputs) => {
      const q = await this.query()
      return q.update(id, inputs as any);
    }

    this.findMany = async (query) => {
      const q = await this.query()
      return q.where(query as any).all();
    }

    this.query = async () => {
      return new Query({
        tableName: '{{ .TableName }}',
        queryResolver: qr,
        logger: queryLogger,
      })
    }
  }
}

export const {{ .Name }} = new {{ .ApiName }}();
{{- end }}
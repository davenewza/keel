package functions

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	_ "embed"

	"github.com/evanw/esbuild/pkg/api"
	"github.com/samber/lo"
	"github.com/teamkeel/keel/codegen"
	"github.com/teamkeel/keel/nodedeps"
	"github.com/teamkeel/keel/proto"
)

// The Custom Functions Runtime package exposes two public methods:
//
// - *Bootstrap()*: codegens all of the required typescript code into the @teamkeel/client node_module in the
// 	 target directory. e.g if the directory is examples/sample_app, typescript code
//   will be generated into examples/sample_app/node_modules/@teamkeel/client/src
//	 and esbuild will transpile this code into examples/sample_app/node_modules/@teamkeel/client/dist
//
// - *Scaffold()*: if a .keel schema has defined a custom function that doesn't have a correspondingingly named
// file at the path {dir}/functions/{name}.ts, then a new typescript file will be scaffolded based on the operation
// type.

type Runtime struct {
	Schema     *proto.Schema
	WorkingDir string
	generator  codegen.Generator
}

type ScaffoldResult struct {
	FunctionsCount int

	CreatedFunctions []string
}

type FunctionImplementation struct {
	Op    *proto.Operation
	Model *proto.Model
}

// todo: make this configurable in the future
var FUNCTIONS_DIRECTORY = "functions"

func NewRuntime(schema *proto.Schema, workDir string) (*Runtime, error) {
	return &Runtime{
		WorkingDir: workDir,
		Schema:     schema,
		generator:  *codegen.NewGenerator(schema),
	}, nil
}

// Bootstrap generates all of the necessary client code (model defs, api defs) plus corresponding typings.
// Additionally, internal runtime javascript code is generated.
// All of the generated typescript code is bundled by esbuild at the end of the process
func (r *Runtime) Bootstrap() error {
	packageJson, err := nodedeps.NewPackageJson(filepath.Join(r.WorkingDir, "package.json"))

	if err != nil {
		return err
	}

	// First we check if there is a package.json file in the directory
	// and perform a reconciliation process to check that it satisfies
	// the dependencies required by the runtime
	// If there is not a package.json, then one is created with all of the correct
	// dependencies.
	err = packageJson.Bootstrap()

	if err != nil {
		return err
	}

	// The typescript code generated here includes:
	// - Interfaces for each model defined in Keel schema
	// - Base type for common scalar types
	// - API implementation (model API, logger etc)
	src := r.generator.GenerateClientCode()

	_, err = r.makeModule(filepath.Join(r.WorkingDir, "node_modules", "@teamkeel", "client", "src", "index.ts"), src)

	if err != nil {
		return err
	}

	// An index.d.ts file is created that types the resulting javascript code.
	err = r.generateClientTypings()

	if err != nil {
		return err
	}

	// In order for a node_module to be resolvable, it needs a package.json
	err = r.generateClientPackageJson()

	if err != nil {
		return err
	}

	// The handler calls startRuntimeServer (from @teamkeel/runtime node module) with
	// a configuration object that is generated by us - this config object contains a
	// record of the custom functions + models in the keel schema
	err = r.generateHandler()

	if err != nil {
		return err
	}

	// We use esbuild to transpile all of the generated typescript code contained in
	// @teamkeel/client/src into @teamkeel/client/dist which means it can be referenced by other
	// node_modules
	_, errs := r.bundle()

	if len(errs) > 0 {
		var errors []string

		for _, err := range errs {
			errors = append(errors, err.Error())
		}

		return fmt.Errorf(strings.Join(errors, ","))
	}

	return nil
}

func RunServer(workingDir string, port string, dbConnectionString string) (*os.Process, error) {
	serverDistPath := filepath.Join(workingDir, "node_modules", "@teamkeel", "client", "dist", "handler.js")

	if _, err := os.Stat(serverDistPath); errors.Is(err, os.ErrNotExist) {
		return nil, err
	}

	cmd := exec.Command("node", filepath.Join("node_modules", "@teamkeel", "client", "dist", "handler.js"))

	cmd.Env = append(cmd.Env, fmt.Sprintf("PORT=%s", port))
	cmd.Env = append(cmd.Env, fmt.Sprintf("DB_CONN=%s", dbConnectionString))
	cmd.Env = append(cmd.Env, fmt.Sprintf("FORCE_COLOR=%d", 1))

	cmd.Dir = workingDir

	var buf bytes.Buffer
	w := io.MultiWriter(os.Stdout, &buf)

	cmd.Stdout = w
	cmd.Stderr = w

	err := cmd.Start()

	if err != nil {
		return nil, err
	}

	return cmd.Process, nil
}

// Scaffolds out any custom functions defined in a schema that haven't had their corresponding
// functions/{name}.ts files created yet.
func (r *Runtime) Scaffold() (s *ScaffoldResult, e error) {
	functionsDir := filepath.Join(r.WorkingDir, FUNCTIONS_DIRECTORY)

	if _, err := os.Stat(functionsDir); errors.Is(err, os.ErrNotExist) {
		err := os.Mkdir(functionsDir, os.ModePerm)

		if err != nil {
			return nil, err
		}
	}

	// We are only inteested in scaffolding out functions defined in a *functions* block
	// In our AST, both built-in Keel operations and custom functions are called Operations
	funcs := lo.FlatMap(r.Schema.Models, func(m *proto.Model, _ int) (ops []*FunctionImplementation) {
		for _, op := range m.Operations {
			if op.Implementation == proto.OperationImplementation_OPERATION_IMPLEMENTATION_CUSTOM {
				ops = append(ops, &FunctionImplementation{
					Model: m,
					Op:    op,
				})
			}
		}

		return ops
	})

	if len(funcs) == 0 {
		return &ScaffoldResult{
			FunctionsCount: 0,
		}, nil
	}

	sr := &ScaffoldResult{
		FunctionsCount: len(funcs),
	}

	// Create each custom function file that is missing from functions/ dir
	for _, f := range funcs {
		path := filepath.Join(r.WorkingDir, FUNCTIONS_DIRECTORY, fmt.Sprintf("%s.ts", f.Op.Name))

		if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {

			src := r.generator.GenerateFunction(f.Op.Name)
			err = os.WriteFile(path, []byte(src), 0644)

			if err != nil {
				return sr, err
			}

			sr.CreatedFunctions = append(sr.CreatedFunctions, path)
		}
	}

	return sr, nil
}

func (r *Runtime) generateClientTypings() error {
	src := r.generator.GenerateClientTypings()

	_, err := r.makeModule(filepath.Join(r.WorkingDir, "node_modules", "@teamkeel", "client", "dist", "index.d.ts"), src)

	if err != nil {
		return err
	}

	return nil
}

func (r *Runtime) generateHandler() error {
	src := r.generator.GenerateEntryPoint()

	_, err := r.makeModule(filepath.Join(r.WorkingDir, "node_modules", "@teamkeel", "client", "src", "handler.js"), src)

	return err
}

//go:embed client-package.json
var clientPackageJson string

func (r *Runtime) generateClientPackageJson() error {
	packageJsonPath := filepath.Join(r.WorkingDir, "node_modules", "@teamkeel", "client", "package.json")
	clientDir := filepath.Dir(packageJsonPath)

	if _, err := os.Stat(clientDir); errors.Is(err, os.ErrNotExist) {
		err := os.Mkdir(clientDir, os.ModePerm)

		if err != nil {
			return err
		}
	}

	f, err := os.Create(packageJsonPath)

	if err != nil {
		return err
	}

	_, err = f.WriteString(clientPackageJson)

	if err != nil {
		return err
	}

	return nil
}

// Bundle transpiles all generated TypeScript files in a working directory using
// esbuild, and outputs the JavaScript equivalent to the OutDir
func (r *Runtime) bundle() (api.BuildResult, []error) {
	// Run esbuild on the generated entrypoint code
	// The entrypoint references the users custom functions
	// so these will be bundled in addition to any generated code
	buildResult := api.Build(api.BuildOptions{
		EntryPoints: []string{
			path.Join(r.WorkingDir, "node_modules", "@teamkeel", "client", "src", "index.ts"),
			path.Join(r.WorkingDir, "node_modules", "@teamkeel", "client", "src", "handler.js"),
		},
		Bundle:   true,
		Outdir:   filepath.Join(r.WorkingDir, "node_modules", "@teamkeel", "client", "dist"),
		Write:    true,
		Platform: api.PlatformNode,
		LogLevel: api.LogLevelError,
		// We don't want esbuild to include @teamkeel/sdk in the bundle as this node_module already
		// exists one level up
		External: []string{
			"@teamkeel/sdk",
			"@teamkeel/runtime",
			"slonik",
			"slonik-interceptor-query-logging",
		},
	})

	if len(buildResult.Errors) > 0 {
		return buildResult, r.buildResultErrors(buildResult.Errors)
	}

	return buildResult, nil
}

func (r *Runtime) buildResultErrors(errs []api.Message) (e []error) {
	for _, err := range errs {
		e = append(e, errors.New(err.Text))
	}
	return e
}

func (r *Runtime) makeModule(path string, code string) (string, error) {
	dir := filepath.Dir(path)

	if _, err := os.Stat(dir); errors.Is(err, os.ErrNotExist) {
		err := os.MkdirAll(dir, os.ModePerm)

		if err != nil {
			return "", err
		}
	}

	err := os.WriteFile(path, []byte(code), 0644)

	if err != nil {
		return "", err
	}

	return path, nil
}

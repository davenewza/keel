
OVERVIEW OF THE RELEVANT GRAPHQL TYPES WE HAVE TO WRANGLE
---------------------------------------------------------

o  Schema
	o  A root level schema.
	o  Instantiate one with NewSchema, which takes only a SchemaConfig

o  SchemaConfig
	o  Has fields for its root level: QUERY, MUTATION, and SUBSCRIPTION
	o  These are all of type Object

o  Object
	o  Instantiate one with NewObject, which takes only an ObjectConfig

o  ObjectConfig
	o  Only relevant fields are Name and Fields
	o  Fields are of type <any> - but so far I've only seen Fields being
	   provided as the value.

o  Fields
	o  Just a map of name (string) to Field instance.

o  Field
	o  A structure that encapsulates an arbitrary field using the following 
	   attributes:
		o  Name (string)
		o  Type (Output)  // Describes what it resolves to, an interface type - see below
		o  Args (FieldConfigArgument) // Parameters passed to the resolver
		o  Resolve (FieldResolveFn) // Function to do the resolving

o  Output
	o  An interface to meta-describe a type that a field will resolve to 
	o  The contract has only these methods:
		o  Name(), Description(), String(), Error()
	o  I have seen two classes of concrete values used:
		o  A graphl native type like String
		o  A graphql.Object defined earlier (hierarchical)

o  Input
	o  Same signature and thus behaviour as Output
	o  Only seen graphql native objects provided as values. I.e. String

o  FieldResolveFn
	o  Just a simple function signature
	o  Return type is <any>

o  FieldConfigArgument
	o  Just a map[string]*ArgumentConfig

o  ArgumentConfig
	o  Just carries a:
		o  Type (Input)
		o  DefaultValue (any)
		o  Description

o  ResolveParams
	o  Carries the arguments in Args (map[string]any)
	o  Haven't seen any other fields of it used yet
	o  But it can carry:
		o  Source (any)
		o  Context (go standard Context)

o  Result
	o  Just a container for:
		o  Data (any)
		o  Errors

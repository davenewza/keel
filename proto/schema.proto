syntax = "proto3";

package proto;

option go_package = "github.com/teamkeel/proto";

import "google/protobuf/wrappers.proto";

message Schema {
    repeated Model models = 1;
}

message Model {
    // The name of the model. Must be in PascalCase and be unique within the schema.
    string name = 1;

    // The fields this model contains
    repeated Field fields = 2;

    // The operations this model defines. Contains both operations that will be auto
    // generated and also custom functions
    repeated Operation operations = 3;

    // Any attributes defined at the model level.
    repeated Attribute attributes = 4;
}

message Field {
    // The name of the model this field belongs to.
    string model_name = 1;

    // The name of the field. Must be in lowerCamelCase and be unique within the model.
    string name = 2;

    // The type of the field.
    FieldType type = 3;

    // Any attributes defined within this field.
    repeated Attribute attributes = 4;
}

message Operation {
    // The name of the model this operation belongs to.
    string model_name = 1;

    // The name of the operation. Must be in lowerCamelCase and be unique across all operations
    // across all models within the schema. This is because in both RPC and GraphQL operations
    // are top-level and so two different models can't both define an operation with the same name.
    string name = 2;

    // The type of this operation.
    OperationType type = 3;

    // Whether this operation will be auto-generated by Keel or implemented with a custom function.
    OperationImplementation implementation = 4;

    // The inputs this operation accepts.
    repeated OperationInput inputs = 5;

    // Any attributes defined within this operation.
    repeated Attribute attributes = 6;
}

message OperationInput {
    // Name of the input. Must be lowerCamelCase and unique within the parent operation.
    string name = 1;

    // The type of this input. If type is OPERATION_INPUT_TYPE_FIELD then `model_name` and `field_name`
    // must also be populated.
    OperationInputType type = 2;

    // Set to true if this input field should accept a list of values. Only applies if `type` is not
    // set to OPERATION_INPUT_TYPE_FIELD
    bool repeated = 3;

    // Set to true if this input field is optional. Only applies if `type` is not
    // set to OPERATION_INPUT_TYPE_FIELD
    bool optional = 4;

    // The name of the model this input field is referring to. Should only be set if `type` is
    // set to OPERATION_INPUT_TYPE_FIELD
    google.protobuf.StringValue model_name = 5;

    // The name of the field inside `model_name` that this input type refers to. Should only 
    // be set if `type` is set to OPERATION_INPUT_TYPE_FIELD
    google.protobuf.StringValue field_name = 6;
}

enum OperationInputType {
    OPERATION_INPUT_TYPE_UNKNOWN = 0;

    // Means the input maps directly to a field on a model
    OPERATION_INPUT_TYPE_FIELD = 1;

    OPERATION_INPUT_TYPE_STRING = 2;
    OPERATION_INPUT_TYPE_BOOL = 3;
    // etc...
}

enum OperationImplementation {
    OPERATION_IMPLEMENTATION_UNKNOWN = 0;

    // Auto means the implementation of the operation is generated by Keel.
    OPERATION_IMPLEMENTATION_AUTO = 1;

    // Custom means the implementation of the operation is provided via custom code.
    // The code itself is not represented in this proto schema. 
    OPERATION_IMPLEMENTATION_CUSTOM = 2;
}

enum OperationType {
    OPERATION_TYPE_UNKNOWN = 0;
    
    // Creates a new record and returns it
    OPERATION_TYPE_CREATE = 1;

    // Returns a single record by looking up on a unique field
    OPERATION_TYPE_GET = 2;

    // Lists records optionally filtering on certain fields. The response would be a
    // an object that supports pagination functionality and contains a "page" of results.
    OPERATION_TYPE_LIST = 3;

    // Update a single record by providing a unique lookup and some fields to update.
    // The resulting record is returned.
    OPERATION_TYPE_UPDATE = 4;

    // Delete a record and returns it's ID
    OPERATION_TYPE_DELETE = 5;
}

message Attribute {
    // Name of the attribute.
    AttributeName name = 1;

    // Arguments passed to this attribute.
    repeated AttributeArgument arguments = 2;
}

message AttributeArgument {
    // Only one of `expression` or `value` should be populated.

    // To avoid very large proto payloads expressions are represented in their string format.
    // For example "ctx.identity == person.identity". Parsing these expresssions should be 
    // very fast and so it's reasonable to do it as required when working with this schema.
    google.protobuf.StringValue expression = 1;

    // A literal value
    AttributeValue value = 2;
}

message AttributeValue {
    // Only one field should be populated

    google.protobuf.StringValue string = 1;
    google.protobuf.BoolValue bool = 2;
    google.protobuf.StringValue ident = 3;
    repeated AttributeValue array = 4;
}

enum AttributeName {
    ATTRIBUTE_NAME_UNKNOWN = 0;
    ATTRIBUTE_NAME_REQUIRED = 1;
    ATTRIBUTE_NAME_UNIQUE = 2;
    ATTRIBUTE_NAME_PERMISSION = 3;
}

enum FieldType {
    FIELD_TYPE_UNKNOWN = 0;
    FIELD_TYPE_STRING = 1;
    FIELD_TYPE_BOOL = 2;
    FIELD_TYPE_INT = 3;
    FIELD_TYPE_TIMESTAMP = 4;
    FIELD_TYPE_DATE = 5;
    FIELD_TYPE_ID = 6;
    FIELD_TYPE_RELATIONSHIP = 7;
    // etc...
}